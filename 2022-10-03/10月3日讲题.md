# A题

第一档20%，L=10，你只需要取B=Y, 这时候Y'=10。

第三档30%：

Y -> Y'>=L

L看成B进制下的数<=Y

看成的数至少是1*B^4+XXX<=Y

B<=40000

枚举B 10~40000，O(logY)去计算Y->Y' >=L

第二档30%：

Y转成B进制，它的最后一位数必定是0~9之间。

Y=A*B+0~9

枚举Y的最后一位是0~9的哪一个，Y-[0..9]是B的倍数，可以直接枚举B是多少（枚举约数是$O(\sqrt Y)$）



100分有两种做法：

1、顺承第二档30%的做法，使用pollard_rho分解质因数，$O(d(Y))$。

T*(Y^(1/4)+d(Y)) * log(Y)

2、顺承第三档30%的做法，

你现在第三档已经解决了    10<=B<=40000，又或者是L>=10000。

B比较大的时候意味着L<10000。

我们可以枚举 L<=Y'<10000，

现在是知道Y‘，知道Y，去算出B

Y'=160，Y=2016，1*B^2+6*B=2016

Y=poly(B)

二分出B就好了。











# B题

30%部分分：

n<=10

枚举删去哪条边O(n)，枚举第一个连通块的点1 O(n)，枚举第二个连通块的点2 O(n)

把重构的树建出来，暴力check每个点的子树是否都<n/2。

从1开始dfs算出每个点的子树大小。

x  size[son[x]]<n/2，n-sz[x]<n/2

O（T*n^4）



60%：

枚举X当作根，去把size[]算出来，

去把>n/2那个儿子P。接下来就要枚举P的子节点Y，Y的子树将被接到X上面。

size[P]>n/2    ,    size[Y]<=n/2, size[P]-size[Y]<=n/2



100%

顺承60%的做法。

记录 f[x] = x中剖出一个子树Y，满足子树Y的大小<=n/2，在所有的这些Y中 sz[Y] 最大是多少



check子树：

x 的每个son[x]：假如size[son[x]]<=n/2 那就无事发生，假如>n/2，check size[son[x]]-f[son[x]]<=n/2



如何DP出 f[x]：（从下自上依次求得）

枚举son[x]，假如size[son[x]]<=n/2，upd( f[x] ,size[son[x]] );

假如size[son[x]]>n/2，upd( f[x] , f[son[x]] );



记录 g[x]  =  X子树以外的部分 S ，S切成两部分，一部分是Y的子树，另一部分是其它，

需要满足size[Y]<=n/2，在所有的这些Y中 sz[Y] 最大是多少。



check答案：

n - sz[x] - g[x] < n/2   ? 1 : 0。



如何DP g[x] :  （从上至下获得结果）

upd( g[x] , g[fa] )

g[fa]是fa子树以外的切分结果

g[x]剩下需要更新的部分是： {fa的子树 \ X的子树}

有可能出现的情况是fa的最大切分是在X的子树里面完成的，所以这一部分就不合法了。



可以记录一个f2[x]：x中剖出一个子树Y，满足子树Y的大小<=n/2，

在所有的这些Y中与f[x]情况不一样的（和f[x]的切分结果不在同一颗子节点的子树内） sz[Y] 最大是多少



f[x]，f2[x]的更新：

枚举son[x]，记录一个准备更新的值P，假如size[son[x]]<=n/2，P=size[son[x]];

假如size[son[x]]>n/2，P=f [son[x]];

假如 P>f[x]，f[x]顶替f2[x]，P顶替f[x]

else 假如 P > f2[x]，P顶替f2[x]。



假如X->fa的更新结果恰好是f[x]，这时候就要利用 f2[x]，upd(g[x],f2[x])

否则说明f[x]的结果不是从X子树完成的，upd(g[x],f[x])。



# C题

我们先仔细观察有什么性质。

每行至多只有一个守卫，每列也至多只有一个守卫。

每两个守卫不能8相邻。

守卫“不能围成圈”，所以剩余部分是联通的。

40%部分分：

枚举每个点开始BFS即可，已直播演示代码写法。



100%：

row[i]表示第 i 行的守卫的列坐标，如果没有的话就是0

col[i] 表示第 i 列的守卫的行坐标，如果没有的话就是0

首先有manhattan(x,y)<=dis(x,y)<=manhattan(x,y)+2



两两曼哈顿距离的求法：

\sum \sum |x1-x2|+|y1-y2|

\sum |x1-x2|  x1-x2  or -x1+x2

枚举一个格子 i,  j  ，我们考虑 i 与 j 的贡献。

i * (1~i-1行的空格数  -  i+1~n行的空格数)

j * (1~j-1列的空格数  -  j+1~m列的空格数)



计算+2的贡献数：

每行都有并且列递增条件     与       每列都有并且行递增条件    是互斥的

有对称性，只需考虑前者如何做。

枚举较小行的下标 $i$  ，枚举较大行的下标  $j$ 。flag维护在 $j$ 扫描的过程中是否每行都有并且都递增、或者都递减

假如是递增的话：(row[i]-1)*(m-row[j]) * 2

假如是递减的：(m-row[i])*(row[j]-1) * 2





# D题

30%部分分

考虑对每个询问暴力dij

所有的有效边都在q[i].l~q[i].r范围内。

dis[y]表示从s号点出发，到达y这个点的最后一条边的最小代价是多少。

dis[y]是不是可达就行了。



100%

dis [ x ] [ y ]  表示从x到y的所有合法路径（路径的编号要递增）中最后一条边的最小值。

把询问按照 q[i].l 从大到小排序。



最开始假设图只有N个点，没有边。

我们把边从m编号到1编号依次加进去，然后维护dis [ ] [ ]数组。



考虑询问答案怎么求。

假如我们新增编号为 i 的边，这意味着 q[ o ].l==i 的询问可以找到它的答案了。

我们把所有这样的询问拿出来，如果dis [ q[o].s ] [ q[o].t ] <= q[o].r 答案就是yes



如何维护dis [ x ] [ y ]：

假如我们新增编号为 i 的边 ( u , v ) ，x->u->v->y，

x->u的路径的编号是比 i 要小的，但你现在没有加进去

所以更新的起点只能是u或者v，也就是更新的点对只能为以下形式 (u,j) ,(v,j)

dis [ u ] [ v ]= dis [ v ] [ u ] = i ;

dis [ u ] [ j ] = min(dis [ u ] [ j ], dis [ v ] [ j ] );

dis [ v ]  [ j ] 同理。